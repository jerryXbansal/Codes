Ex. 4: Write a program using BISON.Simple calculator program in bison


â€¢ Features of the calculator:

- the calculator takes input from standard input.
- As input, on each line an arithmetic expression can be given in the standard
format and the calculator must print the o/p after that.
- The calculator should exit, when the user enters the Ctrl^D (eof) character.
- Supported operators: +, -, *, /, ^, and ().

Procedure:

1. Define Lexical Analysis Rules: Write lexical analysis rules using regular expressions to identify
tokens like identifiers, numbers, operators, etc. Use the flex tool to generate the corresponding lexer
code.
2. Define Syntax Rules: Write Bison grammar rules specifying the syntax of your language.
Bison uses BNF-like notation for specifying grammar rules. These rules define how
different parts of the language can be combined to form valid programs.
3. Handle Tokenization: In your Bison grammar file, specify how tokens generated by the
lexer should be handled. This involves associating token types with grammar symbols and
actions to take when certain combinations of tokens are recognized.
4. Implement Semantic Actions: Define semantic actions associated with grammar rules to
specify what should happen when a certain rule is recognized during parsing. Semantic
actions typically involve constructing abstract syntax trees (ASTs) or executing code.
5. Error Handling: Implement error handling mechanisms to detect and report syntax errors
during parsing. Bison provides facilities for error recovery and reporting.
6. Generate Parser Code: Use the bison tool to generate C code for the parser based on your
Bison grammar file.
7. Integrate Lexer and Parser: Integrate the lexer and parser code into a single program. The
lexer provides tokens to the parser, which uses the Bison-generated parser code to parse the
input according to the grammar rules.
8. Test the Parser: Test the parser with various inputs to ensure that it correctly recognizes
valid programs and detects syntax errors in invalid ones.

Bison program for a calculator:

1. Lexical tokens are defined using %token.
2. Grammar rules are specified using the syntax lhs: rhs.
3. Semantic actions are written within curly braces {} and can include C code.
4. The %left directive specifies the associativity of operators.
5. The yylex() function is the lexer function that provides tokens to the parser.
6. The yyerror() function handles syntax errors.
7. The main() function calls yyparse() to start the parsing process.

//yacc file #include&lt;stdio.h&gt;int regs[26];
int base;
%}
%start list
%union { int a; }
%token DIGIT LETTER
%left &#39;|&#39;
%left &#39;&amp;&#39;
%left &#39;+&#39; &#39;-&#39;
%left &#39;*&#39; &#39;/&#39; &#39;%&#39;
%left UMINUS /*supplies precedence for unary minus */
%% /* beginning of rules section */
list: /*empty */
|
list stat &#39;\n&#39;
|
list error &#39;\n&#39;
{
yyerrok;
}
;
stat: expr
{
printf(&quot;%d\n&quot;,$1);
}
|
LETTER &#39;=&#39; expr
{
regs[$1.a] = $3.a;
}
;
expr: &#39;(&#39; expr &#39;)&#39;
{
$$ = $2;
}
|
expr &#39;*&#39; expr
{
$$.a = $1.a * $3.a;
}
|
expr &#39;/&#39; expr
{
$$.a = $1.a / $3.a;
}
|
expr &#39;%&#39; expr
{
$$.a = $1.a % $3.a;
}
|
expr &#39;+&#39; expr
{
$$.a = $1.a + $3.a;
}
|
expr &#39;-&#39; expr
{
$$.a = $1.a - $3.a;
}
|
expr &#39;&amp;&#39; expr
{
$$.a = $1.a &amp; $3.a;
}
|
expr &#39;|&#39; expr
{
$$.a = $1.a | $3.a;
}
|
&#39;-&#39; expr %prec UMINUS
{
$$.a = -$2.a;
}
|
LETTER
{
$$.a = regs[$1.a];
}
|
number
;
number: DIGIT
{
$$ = $1;
base = ($1.a==0) ? 8 : 10;
} |
number DIGIT
{
$$.a = base * $1.a + $2.a;
}
;
%%
main()
{
return(yyparse());
}
yyerror(s)
char *s;
{
fprintf(stderr, &quot;%s\n&quot;,s);
}
yywrap()
{
return(1);
}


LEX FILE
#include &lt;stdio.h&gt;
#include &quot;y.tab.h&quot;
int c;
%}
%%
&quot; &quot; ;
[a-z] {
c = yytext[0];
yylval.a = c - &#39;a&#39;;
return(LETTER);
}
[0-9] {
c = yytext[0];
yylval.a = c - &#39;0&#39;;
return(DIGIT);
}
[^a-z0-9\b] {
c = yytext[0];
return(c);
}
%%


1) Create the calc.yacc file
2) Create the calc.lex file
3) Run the following commands:
yacc -d calc.yacc
lex -d calc.lex
cc y.tab.c lex.yy.c
./a.out
OUTPUT:
5+4
9
